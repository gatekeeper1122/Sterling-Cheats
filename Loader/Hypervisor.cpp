#include "stdafx.h"

#pragma warning(push)
#pragma warning(disable:4826)

#define HvxCall QWORD _declspec(naked)

static HvxCall ExpansionInstall(DWORD PhysicalAddress, DWORD CodeSize) {
	__asm {
		li r0, 0x72
		sc
		blr
	}
}

static HvxCall ExpansionCall(DWORD ExpansionId, QWORD Param1 = 0, QWORD Param2 = 0, QWORD Param3 = 0, QWORD Param4 = 0) {
	__asm {
		li r0, 0x73
		sc
		blr
	}
}

NTSTATUS Hypervisor::Initialize() {
	BYTE szPeekPoke[472] = {
		0x7D, 0x88, 0x02, 0xA6, 0x91, 0x81, 0xFF, 0xF8, 0xFB, 0xC1, 0xFF, 0xE8,
		0xFB, 0xE1, 0xFF, 0xF0, 0x94, 0x21, 0xFF, 0x90, 0x7C, 0xBF, 0x2B, 0x78,
		0x7C, 0xFE, 0x3B, 0x78, 0x2B, 0x03, 0x00, 0x01, 0x40, 0x99, 0x00, 0x08,
		0x38, 0x63, 0x00, 0x01, 0x2B, 0x24, 0x00, 0x00, 0x40, 0x9A, 0x00, 0x1C,
		0x2B, 0x1F, 0x00, 0xF0, 0x41, 0x98, 0x00, 0x0C, 0x2B, 0x1F, 0x01, 0x00,
		0x40, 0x99, 0x00, 0xD0, 0x88, 0x7F, 0x00, 0x00, 0x48, 0x00, 0x01, 0x7C,
		0x2B, 0x24, 0x00, 0x01, 0x40, 0x9A, 0x00, 0x20, 0x2B, 0x1F, 0x00, 0xF0,
		0x41, 0x98, 0x00, 0x0C, 0x2B, 0x1F, 0x01, 0x00, 0x40, 0x99, 0x00, 0xB0,
		0xA1, 0x7F, 0x00, 0x00, 0x7D, 0x63, 0x07, 0x34, 0x48, 0x00, 0x01, 0x58,
		0x2B, 0x24, 0x00, 0x02, 0x40, 0x9A, 0x00, 0x1C, 0x2B, 0x1F, 0x00, 0xF0,
		0x41, 0x98, 0x00, 0x0C, 0x2B, 0x1F, 0x01, 0x00, 0x40, 0x99, 0x00, 0x8C,
		0x80, 0x7F, 0x00, 0x00, 0x48, 0x00, 0x01, 0x38, 0x2B, 0x24, 0x00, 0x03,
		0x40, 0x9A, 0x00, 0x1C, 0x2B, 0x1F, 0x00, 0xF0, 0x41, 0x98, 0x00, 0x0C,
		0x2B, 0x1F, 0x01, 0x00, 0x40, 0x99, 0x00, 0x6C, 0xE8, 0x7F, 0x00, 0x00,
		0x48, 0x00, 0x01, 0x18, 0x2B, 0x24, 0x00, 0x04, 0x40, 0x9A, 0x00, 0x64,
		0x39, 0x60, 0x28, 0x28, 0x38, 0x80, 0x00, 0x01, 0x7C, 0xC3, 0x33, 0x78,
		0x7D, 0x69, 0x03, 0xA6, 0x4E, 0x80, 0x04, 0x21, 0x57, 0xCA, 0x00, 0x3E,
		0x2F, 0x0A, 0x00, 0x00, 0x40, 0x99, 0x00, 0x3C, 0x7D, 0x49, 0x03, 0xA6,
		0x7F, 0xEB, 0xFB, 0x78, 0x7D, 0x5F, 0x18, 0x50, 0x39, 0x20, 0x00, 0x00,
		0x2B, 0x0B, 0x00, 0xF0, 0x41, 0x98, 0x00, 0x14, 0x2B, 0x0B, 0x01, 0x00,
		0x41, 0x99, 0x00, 0x0C, 0x7D, 0x2A, 0x59, 0xAE, 0x48, 0x00, 0x00, 0x0C,
		0x89, 0x0B, 0x00, 0x00, 0x7D, 0x0A, 0x59, 0xAE, 0x39, 0x6B, 0x00, 0x01,
		0x42, 0x00, 0xFF, 0xDC, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0xB0,
		0x2B, 0x24, 0x00, 0x05, 0x40, 0x9A, 0x00, 0x10, 0x38, 0x60, 0x00, 0x00,
		0x98, 0xDF, 0x00, 0x00, 0x48, 0x00, 0x00, 0x9C, 0x2B, 0x24, 0x00, 0x06,
		0x40, 0x9A, 0x00, 0x10, 0x38, 0x60, 0x00, 0x00, 0xB0, 0xDF, 0x00, 0x00,
		0x48, 0x00, 0x00, 0x88, 0x2B, 0x24, 0x00, 0x07, 0x40, 0x9A, 0x00, 0x10,
		0x38, 0x60, 0x00, 0x00, 0x90, 0xDF, 0x00, 0x00, 0x48, 0x00, 0x00, 0x74,
		0x2B, 0x24, 0x00, 0x08, 0x40, 0x9A, 0x00, 0x10, 0xF8, 0xDF, 0x00, 0x00,
		0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x60, 0x2B, 0x24, 0x00, 0x09,
		0x40, 0x9A, 0x00, 0x54, 0x39, 0x60, 0x28, 0x28, 0x38, 0x80, 0x00, 0x01,
		0x7C, 0xC3, 0x33, 0x78, 0x7D, 0x69, 0x03, 0xA6, 0x4E, 0x80, 0x04, 0x21,
		0x57, 0xCA, 0x00, 0x3E, 0x2F, 0x0A, 0x00, 0x00, 0x40, 0x99, 0x00, 0x2C,
		0x7D, 0x49, 0x03, 0xA6, 0x7F, 0xEB, 0xFB, 0x78, 0x7D, 0x5F, 0x18, 0x50,
		0x7D, 0x2A, 0x58, 0xAE, 0x99, 0x2B, 0x00, 0x00, 0x7C, 0x00, 0x58, 0x6C,
		0x7C, 0x00, 0x04, 0xAC, 0x4C, 0x00, 0x01, 0x2C, 0x39, 0x6B, 0x00, 0x01,
		0x42, 0x00, 0xFF, 0xE8, 0x38, 0x60, 0x00, 0x00, 0x48, 0x00, 0x00, 0x08,
		0x78, 0x63, 0x00, 0x20, 0x38, 0x21, 0x00, 0x70, 0x81, 0x81, 0xFF, 0xF8,
		0x7D, 0x88, 0x03, 0xA6, 0xEB, 0xC1, 0xFF, 0xE8, 0xEB, 0xE1, 0xFF, 0xF0,
		0x4E, 0x80, 0x00, 0x20
	};

	NTSTATUS retVal = 0xC00000A0;

	PBYTE expansionData = (PBYTE)XPhysicalAlloc(0x1000, MAXULONG_PTR, 0, PAGE_READWRITE);
	if (expansionData != NULL) {
		PINSTALL_HEADER hdr = (PINSTALL_HEADER)expansionData;
		DWORD srcAddr = (DWORD)MmGetPhysicalAddress(expansionData);
		memset(expansionData, 0, 0x1000);

		hdr->dwSignature = 'HXPR';
		hdr->fullSize = 0x1000;
		hdr->keyStatus = *(DWORD*)0x8e038610;
		hdr->restrictedPrivs = *(QWORD*)0x8e038630;
		hdr->blockSig = dwExpansionID;
		hdr->srcOffset = 0x160;
		hdr->entryOffset = 0x10;
		hdr->headerSize = 0x10;
		hdr->codeSize = (472 + 0xF) & ~0xF;
		hdr->codeChunkSize = hdr->headerSize + hdr->codeSize;
		memcpy(hdr->code, szPeekPoke, 472);
		XeCryptRandom(hdr->pkcs1data, 0x100);
		XeCryptSha(&expansionData[0x130], hdr->fullSize - 0x130, NULL, 0, NULL, 0, hdr->hash, 0x14);

		srcAddr = (DWORD)MmGetPhysicalAddress(expansionData);
		retVal = (NTSTATUS)ExpansionInstall(srcAddr, hdr->fullSize);

		XPhysicalFree(expansionData);
	}


	return retVal;
}

HRESULT Hypervisor::PeekBytes(QWORD Address, PVOID Buffer, DWORD Size) {
	VOID* data = XPhysicalAlloc(Size, MAXULONG_PTR, 0, PAGE_READWRITE);
	ZeroMemory(data, Size);
	HRESULT result = (HRESULT)ExpansionCall(dwExpansionID, PEEK_BYTES, Address, (QWORD)MmGetPhysicalAddress(data), Size);
	if (result == S_OK)
		memcpy(Buffer, data, Size);
	XPhysicalFree(data);
	return result;
}

HRESULT Hypervisor::PokeBytes(QWORD Address, const void* Buffer, DWORD Size) {
	VOID* data = XPhysicalAlloc(Size, MAXULONG_PTR, 0, PAGE_READWRITE);
	memcpy(data, Buffer, Size);
	HRESULT result = (HRESULT)ExpansionCall(dwExpansionID, POKE_BYTES, Address, (QWORD)MmGetPhysicalAddress(data), Size);
	XPhysicalFree(data);
	return result;
}

BYTE Hypervisor::PeekBYTE(QWORD Address) {
	return (BYTE)ExpansionCall(dwExpansionID, PEEK_BYTE, Address);
}

WORD Hypervisor::PeekWORD(QWORD Address) {
	return (WORD)ExpansionCall(dwExpansionID, PEEK_WORD, Address);
}

DWORD Hypervisor::PeekDWORD(QWORD Address) {
	return (DWORD)ExpansionCall(dwExpansionID, PEEK_DWORD, Address);
}

QWORD Hypervisor::PeekQWORD(QWORD Address) {
	return ExpansionCall(dwExpansionID, PEEK_QWORD, Address);
}

HRESULT Hypervisor::PokeBYTE(QWORD Address, BYTE Value) {
	return (HRESULT)ExpansionCall(dwExpansionID, POKE_BYTE, Address, Value);
}

HRESULT Hypervisor::PokeWORD(QWORD Address, WORD Value) {
	return (HRESULT)ExpansionCall(dwExpansionID, POKE_WORD, Address, Value);
}

HRESULT Hypervisor::PokeDWORD(QWORD Address, DWORD Value) {
	return (HRESULT)ExpansionCall(dwExpansionID, POKE_DWORD, Address, Value);
}

HRESULT Hypervisor::PokeQWORD(QWORD Address, QWORD Value) {
	return (HRESULT)ExpansionCall(dwExpansionID, POKE_QWORD, Address, Value);
}

QWORD Hypervisor::GetFuseLine(BYTE fuseIndex) {
	if (fuseIndex > 11) return 0;
	return PeekQWORD(0x8000020000020000 + (fuseIndex * 0x200));
}

BYTE* Hypervisor::GetHypervisorCPU() {
	BYTE cpukey[0x10];
	PeekBytes(0x20, cpukey, 0x10);
	return cpukey;
}

BYTE* Hypervisor::GetFuseCPU() {
	BYTE cpukey[0x10];
	UINT64 f1p1 = GetFuseLine(3);
	UINT64 f1p2 = GetFuseLine(5);
	memcpy(cpukey, &f1p1, 0x08);
	memcpy(cpukey + 0x08, &f1p2, 0x08);
	return cpukey;
}

BYTE* Hypervisor::GetConsoleType() {
	BYTE version[0x4];
	DWORD val = PeekDWORD(0x14);
	memcpy(version, &val, 0x4);
	return version;
}

#pragma warning(pop)